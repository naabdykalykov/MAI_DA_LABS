\section{Тест производительности}

Для оценки эффективности реализованного алгоритма было проведено сравнение его производительности с эталонной реализацией из стандартной библиотеки C++ --- \texttt{std::stable\_sort}. Сложность \texttt{std::stable\_sort} в лучшем случае составляет $O(N \cdot \log N)$, в то время как реализованная поразрядная сортировка имеет асимптотическую сложность $O(k \cdot N)$, где $k$ --- длина ключа (в данном случае, константа, равная 32).

Тестирование проводилось на наборе данных, состоящем из 1,000,000 ($10^6$) пар <<ключ-значение>> со случайным образом сгенерированными 32-разрядными шестнадцатеричными ключами. Для замера времени использовалась библиотека \texttt{<chrono>}. Компиляция производилась с флагом оптимизации \texttt{-O2}.

\begin{alltt}
laysou@DESKTOP-QPGEK53:/mnt/c/Users/abdyk/Desktop/Lr1/report_pattern$ g++ -O2 -std=c++17 main.cpp -o radix_sorter
laysou@DESKTOP-QPGEK53:/mnt/c/Users/abdyk/Desktop/Lr1/report_pattern$ ./radix_sorter
Radix Sort (by index) time: 0.8521 seconds

laysou@DESKTOP-QPGEK53:/mnt/c/Users/abdyk/Desktop/Lr1/report_pattern$ g++ -O2 -std=c++17 std_sort_version.cpp -o std_sorter
laysou@DESKTOP-QPGEK53:/mnt/c/Users/abdyk/Desktop/Lr1/report_pattern$ ./std_sorter
std::stable_sort time: 2.6154 seconds
\end{alltt}

Как показывают результаты, специализированный алгоритм поразрядной сортировки работает значительно быстрее (примерно в 3 раза), чем универсальный алгоритм \texttt{std::stable\_sort}. Это объясняется тем, что поразрядная сортировка не выполняет посимвольных сравнений строк, а лишь подсчитывает и перемещает индексы, что для данной конкретной задачи является более эффективной стратегией. Линейная сложность нашего алгоритма демонстрирует явное преимущество перед логарифмической сложностью сортировки общего назначения на большом объеме данных.

\pagebreak