\section{Описание}

Для решения поставленной задачи была реализована поразрядная сортировка (Radix Sort), так как она позволяет достичь требуемой линейной временной сложности для ключей фиксированной длины. Ключи представляют собой 32-разрядные шестнадцатеричные числа, что идеально подходит для данного алгоритма. Реализация учитывает жесткие ограничения по памяти.

Общая стратегия заключается в последовательной сортировке данных по каждому разряду ключа (в данном случае — по каждому шестнадцатеричному символу), начиная с младшего разряда и двигаясь к старшему (LSD Radix Sort). Ключевым требованием для корректной работы поразрядной сортировки является использование \textbf{стабильного} алгоритма сортировки в качестве вспомогательного. В качестве такого алгоритма была выбрана сортировка подсчетом (Counting Sort).

Основная идея сортировки подсчетом заключается в том, чтобы для каждого входного 
элемента $x$ определить количество элементов, которые меньше $x$ \cite{Kormen}. В данной реализации эта идея воплощена с помощью техники префиксных сумм и выполняется в несколько этапов для каждого разряда ключа:
\begin{enumerate}
    \item \textbf{Подсчет частот.} Создается вспомогательный массив \texttt{count}, в котором подсчитывается количество вхождений каждого возможного значения разряда (от '0' до 'f').
    \item \textbf{Вычисление позиций.} Массив \texttt{count} преобразуется в массив префиксных сумм. Теперь ячейка \texttt{count[i]} хранит позицию, на которой должен закончиться блок элементов, имеющих значение разряда \texttt{i}. Это позволяет однозначно определить конечное местоположение для каждого элемента.
    \item \textbf{Построение отсортированной последовательности.} Выполняется обход входного массива с конца к началу. Для каждого элемента, исходя из значения его текущего разряда и информации из массива \texttt{count}, определяется его позиция в выходном массиве. Обход с конца гарантирует \textbf{стабильность} сортировки: элементы с одинаковыми ключами по текущему разряду сохраняют свой относительный порядок, который был установлен на предыдущих итерациях.
\end{enumerate}

\subsection{Оптимизация по памяти: сортировка по индексам}
Прямая реализация описанного алгоритма, при которой на каждой из 32 итераций происходит копирование и перемещение структур \texttt{Pair} целиком, приводит к превышению лимита по памяти. Это связано с тем, что поле \texttt{value} может содержать строки значительной длины.

Для решения этой проблемы был применен метод сортировки по посреднику (сортировка индексов).
\begin{enumerate}
    \item Исходные данные \texttt{vector<Pair> data} считываются в память один раз и далее не модифицируются. Они служат статичным хранилищем.
    \item Создается легковесный рабочий вектор \texttt{vector<size\_t> indices}, который изначально инициализируется последовательностью 0, 1, \dots, N-1.
    \item Все операции стабильной сортировки подсчетом производятся исключительно \textbf{над вектором индексов}, а не над вектором данных. Доступ к ключам для сравнения осуществляется косвенно: \texttt{data[indices[i]].key}.
    \item На каждой итерации перемещаются и копируются только целочисленные индексы (\texttt{size\_t}), а не "тяжелые" структуры \texttt{Pair}. Это кардинально снижает пиковое потребление памяти, позволяя уложиться в заданные ограничения.
\end{enumerate}

Таким образом, итоговый алгоритм, комбинируя поразрядную сортировку со стабильной сортировкой подсчетом по индексам, удовлетворяет всем требованиям задачи как по асимптотической сложности, так и по использованию оперативной памяти.

\pagebreak

\section{Исходный код}
Программа написана на языке C++ с использованием стандартной библиотеки. Основная логика вынесена в отдельные функции для улучшения читаемости и модульности.

На каждой непустой строке входного файла располагается пара \enquote{ключ-значение}. Для хранения этих данных в памяти была создана структура \texttt{Pair}, содержащая два поля типа \texttt{std::string} для ключа и значения. Весь ввод-вывод, а также непосредственно алгоритм сортировки, реализованы с помощью набора функций, описанных в таблице ниже.

\begin{longtable}{|p{7.5cm}|p{7.5cm}|}
\hline
\rowcolor{lightgray}
\multicolumn{2}{|c|} {main.cpp}\\
\hline
\texttt{int main()} & Главная функция. Управляет процессом: считывает данные, инициализирует вектор индексов, вызывает сортировку и выводит результат. \\
\hline
\texttt{vector<Pair> read\_input()} & Функция для считывания пар \enquote{ключ-значение} из стандартного ввода и сохранения их в векторе. \\
\hline
\texttt{void print\_output(const vector<Pair>\& data, const vector<size\_t>\& indices)} & Функция для вывода отсортированных данных. Использует отсортированный вектор индексов для доступа к данным в правильном порядке. \\
\hline
\texttt{void radix\_sort\_by\_index(const vector<Pair>\& data, vector<size\_t>\& indices)} & Основная функция поразрядной сортировки (LSD Radix Sort). Организует цикл по разрядам ключа и вызывает для каждого из них вспомогательную функцию сортировки. \\
\hline
\texttt{void counting\_sort\_pass\_by\_index(const vector<Pair>\& data, vector<size\_t>\& indices, int digit\_idx)} & Реализация одного прохода стабильной сортировки подсчетом. Сортирует вектор индексов по заданному разряду ключа, обеспечивая стабильность. \\
\hline
\texttt{int get\_digit\_value(char c)} & Вспомогательная функция, преобразующая шестнадцатеричный символ ('0'-'9', 'a'-'f') в его целочисленное значение (0-15). \\
\hline
\end{longtable}

Структура для хранения данных определена следующим образом:
\begin{lstlisting}[language=C++]
#include <string>
#include <vector>

using namespace std;

struct Pair {
    string key;
    string value;
};
\end{lstlisting}
\pagebreak

\section{Консоль}
\begin{alltt}
laysou@DESKTOP-QPGEK53:/mnt/c/Users/abdyk/Desktop/Lr1/report_pattern$ g++ -Wall -Werror -std=c++17 main.cpp -o radix_sorter
laysou@DESKTOP-QPGEK53:/mnt/c/Users/abdyk/Desktop/Lr1/report_pattern$ cat test1 
a1b2c3d4a1b2c3d4a1b2c3d4a1b2c3d4	Value B (stable 1)
ffffffffffffffffffffffffffffffff	Value D (last)
00000000000000000000000000000000	Value A (first)
a1b2c3d4a1b2c3d4a1b2c3d4a1b2c3d4	Value C (stable 2)
laysou@DESKTOP-QPGEK53:/mnt/c/Users/abdyk/Desktop/Lr1/report_pattern$ ./radix_sorter < test1 
00000000000000000000000000000000	Value A (first)
a1b2c3d4a1b2c3d4a1b2c3d4a1b2c3d4	Value B (stable 1)
a1b2c3d4a1b2c3d4a1b2c3d4a1b2c3d4	Value C (stable 2)
ffffffffffffffffffffffffffffffff	Value D (last)
\end{alltt}
\pagebreak

