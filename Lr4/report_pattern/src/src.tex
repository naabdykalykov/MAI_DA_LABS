\section{Описание}

Для решения поставленной задачи был реализован Z-алгоритм, так как он позволяет находить все вхождения образца в тексте за \textbf{линейное время} от суммарной длины образца и текста. Алгоритм работает с "алфавитом", состоящим из слов, что точно соответствует условию.

Общая стратегия заключается в построении Z-массива для комбинированной строки вида \texttt{P\$T}, где \texttt{P} — искомый образец, \texttt{T} — текст для поиска, а \texttt{\$} — специальный символ-разделитель, который гарантированно не встречается ни в образце, ни в тексте. После вычисления Z-массива, вхождения образца легко находятся по тем индексам, где значение Z-функции равно длине образца.

Ключевым элементом является \textbf{Z-функция}. Для некоторой строки $S$ её Z-массив $Z$ определяется так, что $Z[i]$ — это длина наибольшего общего префикса строки $S$ и её же суффикса, начинающегося с позиции $i$ \cite{Kormen}. Вычисление Z-массива для комбинированной строки выполняется за один проход с использованием следующей оптимизации:
\begin{enumerate}
    \item \textbf{Инициализация Z-значения.} Для каждой новой позиции $i$ проверяется, не попадает ли она в границы $[l, r]$ самого правого из уже найденных Z-блоков. Если попадает, это позволяет инициализировать $Z[i]$ некоторым начальным значением, эффективно используя уже проделанную работу и избегая лишних сравнений.
    \item \textbf{Расширение Z-блока.} После (или вместо) шага инициализации выполняется прямое "наивное" сравнение слов для максимально возможного расширения текущего Z-блока. Сравнение продолжается, пока слова из префикса комбинированной строки и из текущей позиции $i$ совпадают.
    \item \textbf{Обновление границ.} Если найденный для позиции $i$ Z-блок простирается правее, чем текущий самый правый Z-блок (т.е. $i + Z[i] - 1 > r$), то границы $l$ и $r$ обновляются. Это позволяет использовать информацию о новом, более длинном Z-блоке на последующих итерациях.
\end{enumerate}

\pagebreak

\section{Исходный код}
Программа написана на языке C++ с использованием стандартной библиотеки. Основная логика вынесена в отдельные функции для улучшения читаемости и модульности.

На первой строке входного файла задается искомый образец. На последующих строках располагается текст, в котором осуществляется поиск. Для хранения слов текста и их исходных позиций была создана структура \texttt{TextData}. Весь ввод-вывод, а также непосредственно алгоритм поиска, реализованы с помощью набора функций, описанных в таблице ниже.

\begin{longtable}{|p{7.5cm}|p{7.5cm}|}
\hline
\rowcolor{lightgray}
\multicolumn{2}{|c|} {main.cpp}\\
\hline
\texttt{int main()} & Главная функция. Управляет процессом: вызывает функции чтения образца и текста, подготавливает данные для Z-алгоритма, запускает его и выводит найденные вхождения. \\
\hline
\texttt{TextData readText()} & Функция для считывания всех строк текста. Разбивает их на слова, приводит к нижнему регистру и сохраняет вместе с их координатами (номер строки и номер слова). \\
\hline
\texttt{vector<string> readPattern()} & Функция для считывания первой строки ввода, содержащей образец. Также разбивает ее на слова и приводит к нижнему регистру. \\
\hline
\texttt{vector<int> calculateZ(const vector<string>\& s)} & Основная функция, реализующая Z-алгоритм. Вычисляет Z-массив для комбинированной последовательности слов \texttt{P\$T}. \\
\hline
\texttt{void findAndPrintMatches(const vector<int>\& zValues, int pLen, const vector<pair<int, int>>\& coords)} & Функция анализирует посчитанный Z-массив. Находит позиции, где значение Z-функции равно длине образца, и выводит соответствующие им координаты. \\
\hline
\texttt{string toLower(string s)} & Вспомогательная функция, которая преобразует строку в нижний регистр для обеспечения регистронезависимого поиска. \\
\hline
\end{longtable}

\pagebreak

Структура для хранения данных о тексте определена следующим образом:
\begin{lstlisting}[language=C++]
#include <string>
#include <vector>
#include <utility> // for std::pair

struct TextData {
    std::vector<std::string> words;
    std::vector<std::pair<int, int>> coordinates;
};
\end{lstlisting}
\pagebreak

\section{Консоль}
Демонстрация работы программы: компиляция исходного кода, просмотр содержимого тестового файла \texttt{input.txt} и запуск исполняемого файла с перенаправлением ввода для поиска образца в тексте.
\begin{alltt}
\fontfamily{pcr}\selectfont
laysou@DESKTOP-QPGEK53:/mnt/c/Users/abdyk/Desktop/Lr2$ g++ -std=c++17 -O2 -o program main.cpp
laysou@DESKTOP-QPGEK53:/mnt/c/Users/abdyk/Desktop/Lr2$ cat input.txt
cat dog cat dog bird
CAT dog CaT Dog Cat DOG bird CAT
dog cat dog bird
laysou@DESKTOP-QPGEK53:/mnt/c/Users/abdyk/Desktop/Lr2$ ./program < input.txt
1,3
1,8
\end{alltt}
\pagebreak

