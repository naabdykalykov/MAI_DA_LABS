\section{Тест производительности}

Для оценки эффективности реализованного Z-ал-ма было проведено сравнение его производительности с наивной реализацией поиска "в лоб". Асимптотическая сложность Z-ал-ма составляет $O(M+N)$, где $M$ и $N$ — длины образца и текста в словах, что является линейной сложностью. Наивный поиск в худшем случае имеет сложность $O(M \cdot N)$, что значительно медленнее на больших объемах данных.

Тестирование проводилось на большом сгенерированном тексте, состоящем из 10,000,000 ($10^7$) слов. Текст был специально составлен так, чтобы создавать "трудные" условия для наивного ал-ма (большое количество частичных совпадений с образцом). Для замера времени использовалась библиотека \texttt{<chrono>}. Компиляция обоих вариантов производилась с флагом оптимизации \texttt{-O2}.
\begin{alltt}
\fontfamily{pcr}\selectfont
laysou@DESKTOP-QPGEK53:/mnt/c/Users/abdyk/Desktop/Lr2$ g++ -O2 -std=c++17 main.cpp -o z_searcher
laysou@DESKTOP-QPGEK53:/mnt/c/Users/abdyk/Desktop/Lr2$ ./z_searcher < large_test.txt
Z-algorithm search time: 0.3175 seconds

laysou@DESKTOP-QPGEK53:/mnt/c/Users/abdyk/Desktop/Lr2$ g++ -O2 -std=c++17 naive_version.cpp -o naive_searcher
laysou@DESKTOP-QPGEK53:/mnt/c/Users/abdyk/Desktop/Lr2$ ./naive_searcher < large_test.txt
Naive (brute-force) search time: 45.8214 seconds
\end{alltt}

Как показывают результаты, Z-ал-м работает на несколько порядков быстрее (в данном случае, примерно в 140 раз), чем наивный поиск. Это объясняется тем, что Z-ал-м обрабатывает весь текст за один проход, эффективно используя информацию о уже проверенных участках (Z-блоки), чтобы избежать повторных сравнений. Наивный же подход на каждом шаге начинает проверку заново, выполняя огромное количество избыточной работы. Линейная сложность Z-ал-ма демонстрирует колоссальное преимущество перед квадратичной сложностью простого подхода, что делает его единственным рабочим решением для обработки больших текстов.

\pagebreak